{
  "title": "UITextView",
  "cells": [
    {
      "type": "text",
      "data": "<h3>Handle Tap</h3>"
    },
    {
      "type": "text",
      "data": "<h3>With UITapGestureRecognizer</h3>"
    },
    {
      "type": "text",
      "data": "<b>Setup</b> ( viewDidLoad() )"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "let tapRecognizer =  UITapGestureRecognizer(target: self, action: #selector(LearnViewController.handleTap(tapGesture:)))\nself.learnTextView.addGestureRecognizer(tapRecognizer)"
    },
    {
      "type": "text",
      "data": "<b>Very extensive version (from Gist)</b>"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "  @objc func handleTap(tapGesture: UITapGestureRecognizer) {\n    Log.debug?.message(\"Link tapped\")\n    let textView: UITextView = tapGesture.view as! UITextView\n    let tapLocation = tapGesture.location(in: tapGesture.view)\n    \n    var textPosition1 = textView.closestPosition(to: tapLocation)\n    var textPosition2:UITextPosition?\n    if let _ = textPosition1 {\n      textPosition2 = textView.position(from: textPosition1!, offset: 1)\n      if let _ = textPosition2 {\n        textPosition1 = textView.position(from: textPosition1!, offset: -1)\n        textPosition2 = textView.position(from: textPosition1!, offset: 1)\n      } else  {\n        return\n      }\n    }\n\n    let range = textView.textRange(from: textPosition1!, to: textPosition2!)\n    let startOffset = textView.offset(from: textView.beginningOfDocument, to: range!.start)\n    let endOffset = textView.offset(from: textView.beginningOfDocument, to: range!.end)\n    let offsetRange = NSMakeRange(startOffset, endOffset - startOffset)\n    if offsetRange.location == NSNotFound || offsetRange.length == 0 {\n      return\n    }\n    \n    if NSMaxRange(offsetRange) > textView.attributedText.length {\n      return\n    }\n    \n    let attributedSubstring = textView.attributedText .attributedSubstring(from: offsetRange)\n    let link = attributedSubstring.attribute(NSAttributedStringKey.link, at: 0, effectiveRange: nil)\n    \n    if let _ = link {\n      Log.debug?.value(\"\\(String(describing: link))\")\n      return\n    }\n  }"
    },
    {
      "type": "text",
      "data": "<b>Smaller version (working)</b>"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "  @objc func handleTap(tapGesture: UIGestureRecognizer) {\n    Log.debug?.message(\"Link tapped.\")\n\n      if let textView = tapGesture.view as? UITextView\n      {\n        let tapLocation = tapGesture.location(in: textView)\n        let textPosition = textView.closestPosition(to: tapLocation)\n        let attr: NSDictionary = textView.textStyling(at: textPosition!, in: UITextStorageDirection.forward)! as NSDictionary\n    \n        if let url: NSURL = attr[NSAttributedStringKey.link] as? NSURL {\n          // \n          Log.debug?.message(\"Link tapped for url: \\(url)\")\n        }\n    }\n  }"
    },
    {
      "type": "text",
      "data": "<h3>With UITextViewDelegate.shouldInteractWith URL</h3>"
    },
    {
      "type": "code",
      "language": "sh",
      "data": " func textView(_ textView: UITextView, shouldInteractWith URL: URL, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {\n    Log.debug?.message(\"shouldInteractWith URL \\(URL)\")\n    \n    // Do something, e.g. extract URL.\n    \n    return true\n  }"
    },
    {
      "type": "text",
      "data": "<h2>Load HTML String</h2>"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "let htmlString = \"<html>\" +\n        \"<head>\" +\n        \"<style>\" +\n        \"body {\" +\n        \"background-color: rgb(230, 230, 230);\" +\n        \"font-family: 'Arial';\" +\n        \"text-decoration:none;\" +\n        \"}\" +\n        \"</style>\" +\n        \"</head>\" +\n        \"<body>\" +\n        \"<h1>A title</h1>\" +\n        \"<p>A paragraph</p>\" +\n        \"<b>bold text</b>\" +\n    \"</body></head></html>\"\n\nlet htmlData = NSString(string: htmlString).data(using: String.Encoding.unicode.rawValue)\nlet options = [NSAttributedString.DocumentReadingOptionKey.documentType: NSAttributedString.DocumentType.html]\nlet attributedString = try! NSAttributedString(data: htmlData!, options: options, documentAttributes: nil)\ntextView.attributedText = attributedString"
    },
    {
      "type": "text",
      "data": "(Source:&nbsp;<a href=\"https://stackoverflow.com/questions/2454067/display-html-text-in-uitextview\">https://stackoverflow.com/questions/2454067/display-html-text-in-uitextview</a>)"
    },
    {
      "type": "text",
      "data": "<h3>Attach Image</h3>"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "        let myImage = UIImage(named: \"myImage.png\")\n        Log.debug?.message(\"Bundle main URL: \\(Bundle.main.bundleURL)\")\n        let attachment: NSTextAttachment = NSTextAttachment()\n        attachment.image = myImage\n        let attrString: NSAttributedString = NSAttributedString(attachment: attachment)\n        self.myTextView.textStorage.append(attrString)"
    },
    {
      "type": "text",
      "data": "This b.t.w. would only append to the very end."
    },
    {
      "type": "text",
      "data": "<h3>Replace occurrences of whatever (e.g. HTML-Tags) - brute-force, fragile, but working.</h3>"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "extension MyWhatever {\n  func replaceImgPath(_ htmlString: String) -> String {\n    var theReturnString = htmlString\n    let result = htmlString.slices(from: \"<img src=\\\"\", to: \"\\\"\")\n    let bundleUrl: String = Bundle.main.bundleURL.absoluteString\n    \n    result.forEach(\n      {\n        let fullTag = \"\".appending(bundleUrl).appending( $0 )\n        theReturnString = theReturnString.replacingOccurrences(of: $0, with: fullTag)\n      }\n    )\n    \n    return theReturnString\n  }\n}\n\n// Source: https://stackoverflow.com/a/46855903/4295602\nextension String {\n  func ranges(of string: String, options: CompareOptions = .literal) -> [Range<Index>] {\n    var result: [Range<Index>] = []\n    var start = startIndex\n    while let range = range(of: string, options: options, range: start..<endIndex) {\n      result.append(range)\n      start = range.lowerBound < range.upperBound ? range.upperBound : index(range.lowerBound, offsetBy: 1, limitedBy: endIndex) ?? endIndex\n    }\n    return result\n  }\n  func slices(from: String, to: String) -> [Substring] {\n    let pattern = \"(?<=\" + from + \").*?(?=\" + to + \")\"\n    return ranges(of: pattern, options: .regularExpression)\n      .map{ self[$0] }\n  }\n}\""
    }
  ]
}